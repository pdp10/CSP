/*
 * CSP - Backtracking search with forward checking and heuristics.
 * Copyright (C) 2007. Piero Dalle Pezze, -
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License along
 * with this program; if not, write to the Free Software Foundation, Inc.,
 * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 *
 * Created on: 16/06/2007
 * Modifies:
 * 			v.1.1 (18/06/2007): Documentation of the class.
 * 			v.1.0 (16/06/2007): Codify of the class.
 */
package csp;

import java.util.*;

/**
 * This constraint is used by the generator of problems.
 * 
 * @author Piero Dalle Pezze
 * @version 1.1
 * @param <T> the type of objects that this object may be compared to
 */
public class GeneratedConstraint<T extends Comparable<T>> extends HardConstraint<T> {

	/**
	 * It defines a pair <variable, number of constraints>.
	 * 
	 * @author Piero Dalle Pezze
	 * @version 1.1
	 */
	public class ValuePairDisallowed {
		/**
		 * The first object
		 */
		private T first = null;
		/**
		 * The second object
		 */
		private T second = null;
		
		/**
		 * It builds a pair <first,second>
		 * @param first The first object
		 * @param second The second object
		 */
		public ValuePairDisallowed(T first, T second) {
			this.first = first;
			this.second = second;
		}
		/**
		 * It returns the first object of the couple.
		 * @return The first object of the couple.
		 */
		public T getFirst() {
			return first;
		}
		/**
		 * It returns the second object of the couple.
		 * @return The second object of the couple.
		 */
		public T getSecond() {
			return second;
		}
		
		/**
		 * It returns a representation of the pair.
		 * @return A representation of the pair.
		 */
		public String toString() {
			return new String("(" + first.toString() + "," + second.toString() + ")");
		}
		
	} // end inner class ValuePairDisallowed

	/**
	 * A list of value pairs that are not allowed for this constraint.
	 * The size() of this list depends on the tightness value specified in the problem generator.
	 */
	protected LinkedList<ValuePairDisallowed> listDisallowed = new LinkedList<ValuePairDisallowed>();
	
    /**
     * It initializes a binary hard constraint which is generated by the generator of problems.
     * @param variable1 The first variable of the binary hard constraint.
     * @param variable2 The second variable of the binary hard constraint.
     */  
	public GeneratedConstraint(Variable<T> variable1, Variable<T> variable2) {
		super(variable1, variable2);
	}
	
	/**
	 * It returns the list of value pairs disallowed for this constraint.
	 * @return the list of value pairs disallowed for this constraint.
	 */
	public LinkedList<ValuePairDisallowed> getListDisallowed() {
		return listDisallowed;
	}

	/**
	 * It sets the list of value pairs disallowed for this constraint.
	 * @param value1 The first value of the pair.
	 * @param value2 The second value of the pair.
	 */
	public void addDisallowedPair(T value1, T value2) {
		if(value1 != null && value2 != null)
			listDisallowed.add(new ValuePairDisallowed(value1, value2));
	}

	/**
	 * It returns true if the pair (value1, value2) does not appear in the list of disallowed pairs, 
	 * false otherwise.
	 * @param value1 The value for the first variable.
	 * @param value2 The value for the second variable.
	 * @return True if the pair (value1, value2) does not appear in the list of disallowed pairs, 
	 * false otherwise.
	 */
	public boolean isConsistent(T value1, T value2) {
		ValuePairDisallowed disallowPair = null;
		boolean consistent = true;
		for(int i = 0; i < listDisallowed.size() && consistent; i++) {
			disallowPair = listDisallowed.get(i);
			if(disallowPair.first.equals(value1) && disallowPair.second.equals(value2)) {
				// A matching is found
				consistent = false;
			}
		}
		return consistent;
	}
	
    /**
     * {@inheritDoc}
     */
    public String toString() {
    	String print = new String(var1.toString() + " constraint " + var2.toString() + " : ");
    	for(int i = 0; i < listDisallowed.size(); i++) {
    		print = print + listDisallowed.get(i) + " ";
    	}
    	return print;
    }

}
